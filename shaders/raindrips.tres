[gd_resource type="VisualShader" load_steps=17 format=3 uid="uid://bu0vbbj1pyf2e"]

[ext_resource type="Texture2D" uid="uid://cawmdcxtgwdu1" path="res://shaders/textures/rain_drips.tga" id="1_std4c"]
[ext_resource type="Texture2D" uid="uid://dshqx8ta3uh60" path="res://shaders/textures/rain_drip_mask.tga" id="2_l87ae"]

[sub_resource type="VisualShaderNodeExpression" id="VisualShaderNodeExpression_l87ae"]
size = Vector2(1540, 700.00006)
expression = "// Texture2D:75
	vec2 salama = texture(tex_frg_75, n_out88p0).xy;
	salama = (salama * 2.0) - 1.0;
	vec2 masked = salama * maskA;
	float z = sqrt(max(0.0, 1.0 - dot(masked, masked)));
	n_out122p0 = vec3(masked.x, masked.y, z);
	
	
	"

[sub_resource type="VisualShaderNodeFloatConstant" id="VisualShaderNodeFloatConstant_ial4a"]
constant = 0.55

[sub_resource type="VisualShaderNodeFloatFunc" id="VisualShaderNodeFloatFunc_4n6j4"]
function = 31

[sub_resource type="VisualShaderNodeColorConstant" id="VisualShaderNodeColorConstant_df71f"]
constant = Color(0, 0, 0, 1)

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_l87ae"]
input_name = "time"

[sub_resource type="VisualShaderNodeTexture" id="VisualShaderNodeTexture_ial4a"]
expanded_output_ports = [0]
texture = ExtResource("2_l87ae")

[sub_resource type="VisualShaderNodeVaryingGetter" id="VisualShaderNodeVaryingGetter_4n6j4"]
expanded_output_ports = [0]
varying_name = "NormalFromVertex"
varying_type = 4

[sub_resource type="VisualShaderNodeVaryingGetter" id="VisualShaderNodeVaryingGetter_eof7w"]
expanded_output_ports = [0]
varying_name = "VertNormal"
varying_type = 4

[sub_resource type="VisualShaderNodeTexture" id="VisualShaderNodeTexture_6fugw"]
expanded_output_ports = [0]
texture = ExtResource("1_std4c")

[sub_resource type="VisualShaderNodeExpression" id="VisualShaderNodeExpression_jlt2e"]
size = Vector2(2020, 3180)
expression = "//absWS
    vec3 VecNorA1 = (MODEL_MATRIX * vec4(n_out69p0, 1.0)).xyz;
    
    //vertexnormalWS
    vec3 NormalExit = abs(normalize(MODEL_NORMAL_MATRIX * n_out71p0));
    
    //lerp between set1 and set2 with NormalExitX as a mask
    vec2 uvset1 = vec2(VecNorA1.xy);  // Za Z-facing
    vec2 uvset2 = vec2(VecNorA1.zy);  // Za X-facing
    vec2 n_out85p3 = mix(uvset1, uvset2, round(NormalExit.x));
    
    // UVFunc Scale
    vec2 UVDripsScale = vec2(0.80000, 0.80000);
    vec2 UVDripsPivot = vec2(0.00000, 0.00000);
    vec2 n_out88p0 = (n_out85p3 - UVDripsPivot) * UVDripsScale + UVDripsPivot;
    
    // Texture operations
    vec4 n_out75p0_sampled = texture(tex_frg_75, n_out88p0);
    float DripTxB = n_out75p0_sampled.b;
    float DripTxA = n_out75p0_sampled.a;
    vec2 DripTxRG = vec2(n_out75p0_sampled.r, n_out75p0_sampled.g);
    
    //Control Vector 3
    vec3 CtlVecDrips = vec3(round(DripTxB), 0.1, 0.0715);
    
    // AngleBasedDripMask - KORISTI LOKALNO IME!
    float UpperAngleMask = 0.85000;
    float LowerAngleMask = 0.75000;
    float angle_mask = smoothstep(UpperAngleMask, LowerAngleMask, NormalExit.y);
    
    // temporalOffset
    float n_out113p0 = n_out129p0 + DripTxA;
    
    // TemporalCoordinates
    vec2 TimeVectorDrips = vec2(n_out113p0, n_out113p0);
    
    // MaskControlsVector3 + speed
    vec3 VecCmpsrA1 = vec3(round(DripTxB), 0.2, 0.75);
    
    // TemporalMaskControls
    vec2 TemporalMaskControls = mix(vec2(VecCmpsrA1.y), vec2(VecCmpsrA1.z), vec2(DripTxA));
    
    // TemporalMaskUVed
    vec2 TemporalMask = TemporalMaskControls * TimeVectorDrips;
    
     // TemporalUV
        vec2 TemporalUV = TemporalMask + VecNorA1.xy;
        
        // DripAnimation Via Temporal UV - KORISTI tex_frg_130
        vec4 DripLineTexture = texture(tex_frg_130, TemporalUV);
        
        // Izračunaj konačnu vrijednost
        float DripAnimated = CtlVecDrips.x * DripLineTexture.r * angle_mask;
        
        n_out85p0 = DripAnimated;
		
		
		"

[sub_resource type="VisualShaderNodeVaryingSetter" id="VisualShaderNodeVaryingSetter_df71f"]
varying_name = "VertNormal"
varying_type = 4

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_nu0so"]
input_name = "normal"

[sub_resource type="VisualShaderNodeVaryingSetter" id="VisualShaderNodeVaryingSetter_1xcfl"]
varying_name = "NormalFromVertex"
varying_type = 4

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_6fugw"]
expanded_output_ports = [0]
input_name = "vertex"

[resource]
code = "shader_type spatial;
render_mode blend_mix, depth_draw_opaque, depth_test_default, cull_back, diffuse_lambert, specular_schlick_ggx;


// Varyings
varying vec3 var_NormalFromVertex;
varying vec3 var_VertexLocalSpace;
varying vec3 var_VertNormal;

uniform sampler2D tex_frg_75;
uniform sampler2D tex_frg_130;



void vertex() {
// Input:3
	vec3 n_out3p0 = VERTEX;


// VaryingSetter:2
	var_NormalFromVertex = n_out3p0;


// Input:11
	vec3 n_out11p0 = NORMAL;


// VaryingSetter:10
	var_VertNormal = n_out11p0;


	var_VertexLocalSpace = vec3(0.0);
}

void fragment() {
// VaryingGetter:69
	vec3 n_out69p0 = var_NormalFromVertex;


// VaryingGetter:71
	vec3 n_out71p0 = var_VertNormal;


// Texture2D:75
	vec4 n_out75p0 = texture(tex_frg_75, UV);


// Input:129
	float n_out129p0 = TIME;


// Texture2D:130
	vec4 n_out130p0 = texture(tex_frg_130, UV);


	float n_out85p0;
// Expression:85
	n_out85p0 = 0.0;
	{
		//absWS
		    vec3 VecNorA1 = (MODEL_MATRIX * vec4(n_out69p0, 1.0)).xyz;
		    
		    //vertexnormalWS
		    vec3 NormalExit = abs(normalize(MODEL_NORMAL_MATRIX * n_out71p0));
		    
		    //lerp between set1 and set2 with NormalExitX as a mask
		    vec2 uvset1 = vec2(VecNorA1.xy);  // Za Z-facing
		    vec2 uvset2 = vec2(VecNorA1.zy);  // Za X-facing
		    vec2 n_out85p3 = mix(uvset1, uvset2, round(NormalExit.x));
		    
		    // UVFunc Scale
		    vec2 UVDripsScale = vec2(0.80000, 0.80000);
		    vec2 UVDripsPivot = vec2(0.00000, 0.00000);
		    vec2 n_out88p0 = (n_out85p3 - UVDripsPivot) * UVDripsScale + UVDripsPivot;
		    
		    // Texture operations
		    vec4 n_out75p0_sampled = texture(tex_frg_75, n_out88p0);
		    float DripTxB = n_out75p0_sampled.b;
		    float DripTxA = n_out75p0_sampled.a;
		    vec2 DripTxRG = vec2(n_out75p0_sampled.r, n_out75p0_sampled.g);
		    
		    //Control Vector 3
		    vec3 CtlVecDrips = vec3(round(DripTxB), 0.1, 0.0715);
		    
		    // AngleBasedDripMask - KORISTI LOKALNO IME!
		    float UpperAngleMask = 0.85000;
		    float LowerAngleMask = 0.75000;
		    float angle_mask = smoothstep(UpperAngleMask, LowerAngleMask, NormalExit.y);
		    
		    // temporalOffset
		    float n_out113p0 = n_out129p0 + DripTxA;
		    
		    // TemporalCoordinates
		    vec2 TimeVectorDrips = vec2(n_out113p0, n_out113p0);
		    
		    // MaskControlsVector3 + speed
		    vec3 VecCmpsrA1 = vec3(round(DripTxB), 0.2, 0.75);
		    
		    // TemporalMaskControls
		    vec2 TemporalMaskControls = mix(vec2(VecCmpsrA1.y), vec2(VecCmpsrA1.z), vec2(DripTxA));
		    
		    // TemporalMaskUVed
		    vec2 TemporalMask = TemporalMaskControls * TimeVectorDrips;
		    
		     // TemporalUV
		        vec2 TemporalUV = TemporalMask + VecNorA1.xy;
		        
		        // DripAnimation Via Temporal UV - KORISTI tex_frg_130
		        vec4 DripLineTexture = texture(tex_frg_130, TemporalUV);
		        
		        // Izračunaj konačnu vrijednost
		        float DripAnimated = CtlVecDrips.x * DripLineTexture.r * angle_mask;
		        
		        n_out85p0 = DripAnimated;
				
				
				
	}


// FloatFunc:124
	float n_out124p0 = 1.0 - n_out85p0;


// FloatConstant:123
	float n_out123p0 = 0.550000;


// Output:0
	ALBEDO = vec3(n_out85p0);
	ROUGHNESS = n_out124p0;
	SPECULAR = n_out123p0;


}
"
varyings/NormalFromVertex = "0,4"
varyings/VertexLocalSpace = "0,4"
varyings/VertNormal = "0,4"
nodes/vertex/0/position = Vector2(420, 100)
nodes/vertex/2/node = SubResource("VisualShaderNodeVaryingSetter_1xcfl")
nodes/vertex/2/position = Vector2(220, 1220)
nodes/vertex/3/node = SubResource("VisualShaderNodeInput_6fugw")
nodes/vertex/3/position = Vector2(-800, 1160)
nodes/vertex/10/node = SubResource("VisualShaderNodeVaryingSetter_df71f")
nodes/vertex/10/position = Vector2(320, 1720)
nodes/vertex/11/node = SubResource("VisualShaderNodeInput_nu0so")
nodes/vertex/11/position = Vector2(-720, 1720)
nodes/vertex/connections = PackedInt32Array(11, 0, 10, 0, 3, 0, 2, 0)
nodes/fragment/0/position = Vector2(-680, -3160)
nodes/fragment/69/node = SubResource("VisualShaderNodeVaryingGetter_4n6j4")
nodes/fragment/69/position = Vector2(-5580, -3540)
nodes/fragment/71/node = SubResource("VisualShaderNodeVaryingGetter_eof7w")
nodes/fragment/71/position = Vector2(-5580, -3140)
nodes/fragment/75/node = SubResource("VisualShaderNodeTexture_6fugw")
nodes/fragment/75/position = Vector2(-5580, -2740)
nodes/fragment/85/node = SubResource("VisualShaderNodeExpression_jlt2e")
nodes/fragment/85/position = Vector2(-4280, -3260)
nodes/fragment/85/size = Vector2(2020, 3180)
nodes/fragment/85/input_ports = "0,4,n_out69p0;1,4,n_out71p0;2,5,n_out75p0;3,0,TIME;4,5,n_out130p0;"
nodes/fragment/85/output_ports = "0,0,Izlaz;"
nodes/fragment/85/expression = "//absWS
    vec3 VecNorA1 = (MODEL_MATRIX * vec4(n_out69p0, 1.0)).xyz;
    
    //vertexnormalWS
    vec3 NormalExit = abs(normalize(MODEL_NORMAL_MATRIX * n_out71p0));
    
    //lerp between set1 and set2 with NormalExitX as a mask
    vec2 uvset1 = vec2(VecNorA1.xy);  // Za Z-facing
    vec2 uvset2 = vec2(VecNorA1.zy);  // Za X-facing
    vec2 n_out85p3 = mix(uvset1, uvset2, round(NormalExit.x));
    
    // UVFunc Scale
    vec2 UVDripsScale = vec2(0.80000, 0.80000);
    vec2 UVDripsPivot = vec2(0.00000, 0.00000);
    vec2 n_out88p0 = (n_out85p3 - UVDripsPivot) * UVDripsScale + UVDripsPivot;
    
    // Texture operations
    vec4 n_out75p0_sampled = texture(tex_frg_75, n_out88p0);
    float DripTxB = n_out75p0_sampled.b;
    float DripTxA = n_out75p0_sampled.a;
    vec2 DripTxRG = vec2(n_out75p0_sampled.r, n_out75p0_sampled.g);
    
    //Control Vector 3
    vec3 CtlVecDrips = vec3(round(DripTxB), 0.1, 0.0715);
    
    // AngleBasedDripMask - KORISTI LOKALNO IME!
    float UpperAngleMask = 0.85000;
    float LowerAngleMask = 0.75000;
    float angle_mask = smoothstep(UpperAngleMask, LowerAngleMask, NormalExit.y);
    
    // temporalOffset
    float n_out113p0 = n_out129p0 + DripTxA;
    
    // TemporalCoordinates
    vec2 TimeVectorDrips = vec2(n_out113p0, n_out113p0);
    
    // MaskControlsVector3 + speed
    vec3 VecCmpsrA1 = vec3(round(DripTxB), 0.2, 0.75);
    
    // TemporalMaskControls
    vec2 TemporalMaskControls = mix(vec2(VecCmpsrA1.y), vec2(VecCmpsrA1.z), vec2(DripTxA));
    
    // TemporalMaskUVed
    vec2 TemporalMask = TemporalMaskControls * TimeVectorDrips;
    
     // TemporalUV
        vec2 TemporalUV = TemporalMask + VecNorA1.xy;
        
        // DripAnimation Via Temporal UV - KORISTI tex_frg_130
        vec4 DripLineTexture = texture(tex_frg_130, TemporalUV);
        
        // Izračunaj konačnu vrijednost
        float DripAnimated = CtlVecDrips.x * DripLineTexture.r * angle_mask;
        
        n_out85p0 = DripAnimated;
		
		
		"
nodes/fragment/122/node = SubResource("VisualShaderNodeExpression_l87ae")
nodes/fragment/122/position = Vector2(-1960, -4280)
nodes/fragment/122/size = Vector2(1540, 700.00006)
nodes/fragment/122/input_ports = "0,0,maskA;"
nodes/fragment/122/output_ports = "0,4,n_out122p0;"
nodes/fragment/122/expression = "// Texture2D:75
	vec2 salama = texture(tex_frg_75, n_out88p0).xy;
	salama = (salama * 2.0) - 1.0;
	vec2 masked = salama * maskA;
	float z = sqrt(max(0.0, 1.0 - dot(masked, masked)));
	n_out122p0 = vec3(masked.x, masked.y, z);
	
	
	"
nodes/fragment/123/node = SubResource("VisualShaderNodeFloatConstant_ial4a")
nodes/fragment/123/position = Vector2(-1600, -2560)
nodes/fragment/124/node = SubResource("VisualShaderNodeFloatFunc_4n6j4")
nodes/fragment/124/position = Vector2(-1600, -2880)
nodes/fragment/125/node = SubResource("VisualShaderNodeColorConstant_df71f")
nodes/fragment/125/position = Vector2(5140, -3900)
nodes/fragment/129/node = SubResource("VisualShaderNodeInput_l87ae")
nodes/fragment/129/position = Vector2(-5640, -2000)
nodes/fragment/130/node = SubResource("VisualShaderNodeTexture_ial4a")
nodes/fragment/130/position = Vector2(-5600, -1760)
nodes/fragment/connections = PackedInt32Array(69, 0, 85, 0, 71, 0, 85, 1, 124, 0, 0, 3, 123, 0, 0, 4, 75, 0, 85, 2, 129, 0, 85, 3, 85, 0, 124, 0, 85, 0, 0, 0, 130, 0, 85, 4)
